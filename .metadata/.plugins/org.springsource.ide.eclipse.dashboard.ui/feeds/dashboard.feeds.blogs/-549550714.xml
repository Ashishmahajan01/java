<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Spring]]></title><description><![CDATA[Level up your Java code and explore what Spring can do for you.]]></description><link>https://spring.io</link><generator>GatsbyJS</generator><lastBuildDate>Thu, 13 Jul 2023 16:50:44 GMT</lastBuildDate><item><title><![CDATA[New in Spring 6.1: RestClient]]></title><link>https://spring.io/blog/2023/07/13/new-in-spring-6-1-restclient</link><guid isPermaLink="true">https://spring.io/blog/2023/07/13/new-in-spring-6-1-restclient</guid><dc:creator><![CDATA[Arjen Poutsma]]></dc:creator><pubDate>Thu, 13 Jul 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Spring Framework 6.1 M2 introduces the &lt;code&gt;RestClient&lt;/code&gt;, a new synchronous HTTP client.
As the name suggests, &lt;code&gt;RestClient&lt;/code&gt; offers the fluent API of &lt;code&gt;WebClient&lt;/code&gt; with the infrastructure of &lt;code&gt;RestTemplate&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Fourteen years ago, when &lt;code&gt;RestTemplate&lt;/code&gt; was introduced in Spring Framework 3.0, we quickly discovered that exposing every capability of HTTP in a template-like class resulted in too many overloaded methods.
In Spring Framework 5, we therefore used a fluent API for the reactive &lt;code&gt;WebClient&lt;/code&gt;.
With &lt;code&gt;RestClient&lt;/code&gt; we are introducing a HTTP client that offers an API similar to &lt;code&gt;WebClient&lt;/code&gt;, and that uses the message converters, request factories, interceptors, and other underlying components of &lt;code&gt;RestTemplate&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;Creating a &lt;code&gt;RestClient&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;You can create a &lt;code&gt;RestClient&lt;/code&gt; using one of the static &lt;code&gt;create&lt;/code&gt; methods.
You can also use &lt;code&gt;RestClient::builder&lt;/code&gt; to get a builder with further options, such as specifying the HTTP client to use, setting a default URL, path variables, and headers, or registering interceptors and initializers.&lt;/p&gt;
&lt;p&gt;Using &lt;code&gt;RestClient::create(RestTemplate)&lt;/code&gt;, you can initialize a &lt;code&gt;RestClient&lt;/code&gt; with the configuration of an existing &lt;code&gt;RestTemplate&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;Retrieve&lt;/h2&gt;
&lt;p&gt;Let&apos;s create a &lt;code&gt;RestClient&lt;/code&gt;, use it to set up a basic &lt;code&gt;GET&lt;/code&gt; request, and retrieve the contents of a site as string using &lt;code&gt;retrieve&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;RestClient restClient = RestClient.create();

String result = restClient.get()
  .uri(&quot;https://example.com&quot;)
  .retrieve()
  .body(String.class);
System.out.println(result);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you&apos;re interested in the response status code and headers, and not just the contents, you can use &lt;code&gt;toEntity&lt;/code&gt; to get a &lt;code&gt;ResponseEntity&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;ResponseEntity&amp;#x3C;String&gt; result = restClient.get()
  .uri(&quot;https://example.com&quot;)
  .retrieve()
  .toEntity(String.class);

System.out.println(&quot;Response status: &quot; + result.getStatusCode());
System.out.println(&quot;Response headers: &quot; + result.getHeaders());
System.out.println(&quot;Contents: &quot; + result.getBody());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;RestClient&lt;/code&gt; can also convert JSON to objects, using Jackson under the hood.
In fact, it can convert all types that &lt;code&gt;RestTemplate&lt;/code&gt; supports, as it uses the same &lt;a href=&quot;https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-config/message-converters.html&quot;&gt;message converters&lt;/a&gt;.
Note the usage of uri variables, and that the &lt;code&gt;Accept&lt;/code&gt; header is set to JSON.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;int id = ...
Pet pet = restClient.get()
  .uri(&quot;https://petclinic.example.com/pets/{id}&quot;, id)
  .accept(APPLICATION_JSON)
  .retrieve()
  .body(Pet.class);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;POST&lt;/h3&gt;
&lt;p&gt;Doing a &lt;code&gt;POST&lt;/code&gt; request is just as simple, like so:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Pet pet = ...
ResponseEntity&amp;#x3C;Void&gt; response = restClient.post()
  .uri(&quot;https://petclinic.example.com/pets/new&quot;)
  .contentType(APPLICATION_JSON)
  .body(pet)
  .retrieve()
  .toBodilessEntity();
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Error handling&lt;/h3&gt;
&lt;p&gt;By default, &lt;code&gt;RestClient&lt;/code&gt; throws a subclass of &lt;code&gt;RestClientException&lt;/code&gt; when receiving a 4xx or 5xx status code.
This behavior can be overriden using status handlers, like so:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;String result = restClient.get()
  .uri(&quot;https://example.com/this-url-does-not-exist&quot;)
  .retrieve()
  .onStatus(HttpStatusCode::is4xxClientError, (request, response) -&gt; {
      throw new MyCustomRuntimeException(response.getStatusCode(), response.getHeaders())
  })
  .body(String.class);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Exchange&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;RestClient&lt;/code&gt; offers the &lt;code&gt;exchange&lt;/code&gt; method for more advanced scenarios, as it provides access to the underlying HTTP request and response.
The previously mentioned status handlers are &lt;em&gt;not&lt;/em&gt; applied when you use &lt;code&gt;exchange&lt;/code&gt;, because the exchange function already provides access to the full response, allowing you to perform any error handling necessary:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Pet result = restClient.get()
  .uri(&quot;https://petclinic.example.com/pets/{id}&quot;, id)
  .accept(APPLICATION_JSON)
  .exchange((request, response) -&gt; {
    if (response.getStatusCode().is4xxClientError()) {
      throw new MyCustomRuntimeException(response.getStatusCode(), response.getHeaders());
    }
    else {
      Pet pet = convertResponse(response);
      return pet;
    }
  });
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Support for &lt;code&gt;RestClient&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;RestClient&lt;/code&gt; is just one of the &lt;a href=&quot;https://github.com/spring-projects/spring-framework/wiki/What&amp;#x27;s-New-in-Spring-Framework-6.x#whats-new-in-version-61&quot;&gt;many features&lt;/a&gt; that Spring Framework 6.1 offers.
Various components already support &lt;code&gt;RestClient&lt;/code&gt;: you can test its usage through the &lt;a href=&quot;https://docs.spring.io/spring-framework/reference/testing/spring-mvc-test-client.html&quot;&gt;&lt;code&gt;MockRestServiceServer&lt;/code&gt;&lt;/a&gt;, or use it as the backend for &lt;a href=&quot;https://docs.spring.io/spring-framework/reference/integration/rest-clients.html#rest-http-interface&quot;&gt;&lt;code&gt;@HttpExchange&lt;/code&gt; interfaces&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Additionally, &lt;a href=&quot;https://github.com/spring-projects/spring-boot/milestone/304&quot;&gt;Spring Boot 3.2 M1&lt;/a&gt; will include support for the &lt;code&gt;RestClient&lt;/code&gt;.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Spring Framework 6.1 M2 released]]></title><link>https://spring.io/blog/2023/07/13/spring-framework-6-1-m2-released</link><guid isPermaLink="true">https://spring.io/blog/2023/07/13/spring-framework-6-1-m2-released</guid><dc:creator><![CDATA[Brian Clozel]]></dc:creator><pubDate>Thu, 13 Jul 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;On behalf of the Spring Framework framework team, it is my pleasure to announce that the second Spring Framework 6.1 milestone release is available from &lt;a href=&quot;htts://repo.spring.io/milestone&quot;&gt;repo.spring.io/milestone&lt;/a&gt; now. This new version builds on the &lt;a href=&quot;https://spring.io/blog/2023/06/15/spring-framework-6-1-m1-released&quot;&gt;main 6.1 themes introduced in the first milestone&lt;/a&gt; and adds new ones: &lt;code&gt;@Scheduled&lt;/code&gt; improvements and the introduction of &lt;code&gt;RestClient&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;Main themes status update&lt;/h2&gt;
&lt;p&gt;The Data Binding and validation worked has made progress and we have now completed the &lt;a href=&quot;https://github.com/spring-projects/spring-framework/issues/30645&quot;&gt;&quot;Built-in Web Support for Method Bean Validation&quot; umbrella issue&lt;/a&gt; and &lt;a href=&quot;https://docs.spring.io/spring-framework/reference/6.1/web/webmvc/mvc-controller/ann-validation.html&quot;&gt;documented the feature accordingly&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Thanks to the Virtual Threads theme, &lt;a href=&quot;https://github.com/spring-projects/spring-framework/issues/30678&quot;&gt;blocking execution of WebFlux Controllers can now be scheduled on a &lt;code&gt;VirtualThreadTaskExecutor&lt;/code&gt;&lt;/a&gt;, if available.&lt;/p&gt;
&lt;p&gt;The Checkpoint/Restore feature is still ongoing, with &lt;a href=&quot;https://github.com/spring-projects/spring-framework/issues/30876&quot;&gt;developer experience updates&lt;/a&gt; and &lt;a href=&quot;https://github.com/spring-projects/spring-framework/issues/30831&quot;&gt;lifecycle improvements of &lt;code&gt;ThreadPoolTaskExecutor&lt;/code&gt; and &lt;code&gt;ThreadPoolTaskScheduler&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;New 6.1 themes&lt;/h2&gt;
&lt;p&gt;This version introduces a new and exciting &lt;code&gt;RestClient&lt;/code&gt; type. This is an important feature that deserves its own blog post: &lt;a href=&quot;https://spring.io/blog/2023/07/13/new-in-spring-6-1-restclient&quot;&gt;check out Arjen&apos;s take on the new &lt;code&gt;RestClient&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;We are improving the &lt;code&gt;@Scheduled&lt;/code&gt; support with two new features. You can now &lt;a href=&quot;https://github.com/spring-projects/spring-framework/issues/20818&quot;&gt;use multiple &lt;code&gt;TaskSchedulers&lt;/code&gt; thanks to a new &lt;code&gt;scheduler&lt;/code&gt; attribute on the &lt;code&gt;@Scheduled&lt;/code&gt; annotation&lt;/a&gt;. The Observability enthusiasts also requested metrics and traces support for &lt;code&gt;@Scheduled&lt;/code&gt; methods - &lt;a href=&quot;https://github.com/spring-projects/spring-framework/issues/29883#issuecomment-1591896876&quot;&gt;it&apos;s now available with a direct Micrometer instrumentation&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;What&apos;s next&lt;/h2&gt;
&lt;p&gt;Check out our &lt;a href=&quot;https://github.com/spring-projects/spring-framework/wiki/What&amp;#x27;s-New-in-Spring-Framework-6.x&quot;&gt;What&apos;s New page&lt;/a&gt; for details about the specific features shipped so far.&lt;/p&gt;
&lt;p&gt;The first Spring Boot 3.2 milestone &lt;a href=&quot;https://calendar.spring.io/&quot;&gt;will be released next week&lt;/a&gt;. Perfect timing for trying out the new features and preparing for future upgrades! Let us know how it goes, you have a chance to help us shape this 6.1 generation for its general availability in November.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Spring Framework 5.2.25.RELEASE, 5.3.29 and 6.0.11 available now]]></title><link>https://spring.io/blog/2023/07/13/spring-framework-5-2-25-release-5-3-29-and-6-0-11-available-now</link><guid isPermaLink="true">https://spring.io/blog/2023/07/13/spring-framework-5-2-25-release-5-3-29-and-6-0-11-available-now</guid><dc:creator><![CDATA[Brian Clozel]]></dc:creator><pubDate>Thu, 13 Jul 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;On behalf of the team and everyone who has contributed, I am pleased to announce that Spring Framework &lt;code&gt;5.2.25.RELEASE&lt;/code&gt;, &lt;code&gt;5.3.29&lt;/code&gt; and &lt;code&gt;6.0.11&lt;/code&gt; are available now.&lt;/p&gt;
&lt;p&gt;Spring Framework &lt;code&gt;5.2.25.RELEASE&lt;/code&gt; ships with &lt;a href=&quot;https://github.com/spring-projects/spring-framework/releases/tag/v5.2.25.RELEASE&quot;&gt;2 fixes improvements&lt;/a&gt;. This is an out-of-cycle release that will not be shipped with a new Spring Boot version, &lt;a href=&quot;https://spring.io/projects/spring-boot#support&quot;&gt;as Spring Boot 2.3.x is EOL&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Spring Framework &lt;code&gt;5.3.29&lt;/code&gt; ships with &lt;a href=&quot;https://github.com/spring-projects/spring-framework/releases/tag/v5.3.29&quot;&gt;22 fixes and documentation improvements&lt;/a&gt;, including &lt;a href=&quot;https://github.com/spring-projects/spring-framework/issues?q=is%3Aclosed+milestone%3A5.3.29+label%3A%22type%3A+regression%22&quot;&gt;3 fixes for regressions&lt;/a&gt;. This version will be shipped with Spring Boot 2.7.14, &lt;a href=&quot;https://calendar.spring.io/&quot;&gt;to be released next week&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Spring Framework &lt;code&gt;6.0.11&lt;/code&gt; ships with &lt;a href=&quot;https://github.com/spring-projects/spring-framework/releases/tag/v6.0.11&quot;&gt;71 fixes and documentation improvements&lt;/a&gt;, including &lt;a href=&quot;https://github.com/spring-projects/spring-framework/issues?q=is%3Aclosed+milestone%3A6.0.11+label%3A%22type%3A+regression%22&quot;&gt;7 fixes for regressions&lt;/a&gt;. This version will be shipped with Spring Boot 3.0.9 and 3.1.2, &lt;a href=&quot;https://calendar.spring.io/&quot;&gt;to be released next week&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The next Spring Framework releases are scheduled for August 17th with the last 6.1.0 milestone. On September 14th we are expecting a new 6.0.x maintenance release and the first release candidate for 6.1.0.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://spring.io/projects/spring-framework/&quot;&gt;Project Page&lt;/a&gt; | &lt;a href=&quot;https://github.com/spring-projects/spring-framework&quot;&gt;GitHub&lt;/a&gt; | &lt;a href=&quot;https://github.com/spring-projects/spring-framework/issues&quot;&gt;Issues&lt;/a&gt; | &lt;a href=&quot;https://docs.spring.io/spring-framework/reference/&quot;&gt;Documentation&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Spring Web Flow 3.0.0 Released]]></title><link>https://spring.io/blog/2023/07/13/spring-web-flow-3-0-0-released</link><guid isPermaLink="true">https://spring.io/blog/2023/07/13/spring-web-flow-3-0-0-released</guid><dc:creator><![CDATA[Rossen Stoyanchev]]></dc:creator><pubDate>Thu, 13 Jul 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;I&apos;m pleased to announce the availability of Spring Web Flow 3.0.0. This release is all about compatibility with Spring Framework 6 and Jakarta EE. The &lt;a href=&quot;https://github.com/spring-projects/spring-webflow-samples&quot;&gt;spring-webflow-sampes&lt;/a&gt; have been updated, and the commit history provides an example of changes necessary to upgrade. One significant change is the need to remove Tiles which has not migrated to Jakarta EE. The booking-mvc sample now  uses Thymeleaf Layouts instead.&lt;/p&gt;
&lt;p&gt;Once again special thanks to Ian Young, Scott Cantor, and
Gábor Lipták for your help to make these updates available to the community!&lt;/p&gt;</content:encoded></item><item><title><![CDATA[A Bootiful Podcast: Spring Framework and Spring Boot legend Stéphane Nicoll on a Bootiful Podcast]]></title><link>https://spring.io/blog/2023/07/13/a-bootiful-podcast-spring-framework-and-spring-boot-legend-stephane-nicoll</link><guid isPermaLink="true">https://spring.io/blog/2023/07/13/a-bootiful-podcast-spring-framework-and-spring-boot-legend-stephane-nicoll</guid><dc:creator><![CDATA[Josh Long]]></dc:creator><pubDate>Thu, 13 Jul 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Hi, Spring fans! Welcome to another installment of &lt;em&gt;A Bootiful Podcast&lt;/em&gt;! In this installment, &lt;a href=&quot;https://youtube.com/@coffeesoftware&quot;&gt;Josh Long&lt;/a&gt; talk to Spring team legend &lt;a href=&quot;https://twitter.com/snicoll&quot;&gt;Stéphane Nicoll (@snicoll)&lt;/a&gt; about Spring Boot, Apache Maven and Gradle, his journey to the Spring team, and so much more. This episode was recorded live from beautiful Barcelona, Spain, from the epic Spring I/O event in May of 2023!&lt;/p&gt;
&lt;iframe title=&quot;Spring Framework and Spring Boot legend Stéphane Nicoll on a Bootiful Podcast&quot; allowtransparency=&quot;true&quot; height=&quot;150&quot; width=&quot;100%&quot; style=&quot;border: none; min-width: min(100%, 430px);height:150px;&quot; scrolling=&quot;no&quot; data-name=&quot;pb-iframe-player&quot; src=&quot;https://www.podbean.com/player-v2/?i=4cw8d-1455498-pb&amp;from=pb6admin&amp;share=1&amp;download=1&amp;rtl=0&amp;fonts=Arial&amp;skin=1&amp;font-color=&amp;logo_link=episode_page&amp;btn-skin=7&quot; loading=&quot;lazy&quot;&gt;&lt;/iframe&gt;</content:encoded></item><item><title><![CDATA[Spring Initializr 0.20.0 available now]]></title><link>https://spring.io/blog/2023/07/11/spring-initializr-0-20-0-available-now</link><guid isPermaLink="true">https://spring.io/blog/2023/07/11/spring-initializr-0-20-0-available-now</guid><dc:creator><![CDATA[Stéphane Nicoll]]></dc:creator><pubDate>Tue, 11 Jul 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;On behalf of the team and everyone who has contributed, I&apos;m happy to announce that Spring Initializr &lt;code&gt;0.20.0&lt;/code&gt; has been released and is now available from Maven Central.&lt;/p&gt;
&lt;p&gt;This release adds a number of &lt;a href=&quot;https://github.com/spring-io/initializr/releases/tag/v0.20.0&quot;&gt;new features and improvements&lt;/a&gt;. For full upgrade instructions and new and noteworthy features please see the &lt;a href=&quot;https://github.com/spring-io/initializr/wiki/Spring-Initializr-0.20-Release-Notes&quot;&gt;release notes&lt;/a&gt;.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Azure Spring Apps Enterprise – More Power, Scalability & Extended Spring Boot Support]]></title><link>https://spring.io/blog/2023/07/11/azure-spring-apps-enterprise-more-power-scalability-and-extended-spring-boot</link><guid isPermaLink="true">https://spring.io/blog/2023/07/11/azure-spring-apps-enterprise-more-power-scalability-and-extended-spring-boot</guid><dc:creator><![CDATA[Josh Long]]></dc:creator><pubDate>Tue, 11 Jul 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Can you believe Spring is celebrating its 20th anniversary this year?  We could not have gotten here without our millions of Spring developers across the globe, thank you! Spring has been an essential tool for Java developers, and it continues to grow and innovate at a fast pace. From the onset, Azure and VMware Tanzu have been trusted partners to customers for running mission-critical Java and Spring workloads. Our commitment and fondness for the Java Spring developer community have never wavered.&lt;/p&gt;
&lt;h2&gt;Microsoft and VMware Tanzu Collaboration Continues&lt;/h2&gt;
&lt;p&gt;Microsoft collaboration with the Spring team, which began in 2016, has been fundamental to our shared goal of enabling Spring apps to fully harness the power of the cloud. We have listened to Spring developers express their desire to focus on their application code and business logic, rather than being bogged down by the complexities of managing, securing, and scaling infrastructure, containers, and virtual machines. To address this, Microsoft and VMware Tanzu teamed up to establish Azure Spring Apps - an initiative aimed at simplifying your development and operations workflows and expediting your journey from code to production. As a key service within the Microsoft Azure ecosystem, Azure Spring Apps has already garnered significant traction. Many customers including &lt;a href=&quot;https://aka.ms/Bosch.IO&quot;&gt;Bosch&lt;/a&gt;, &lt;a href=&quot;https://aka.ms/DLR&quot;&gt;Digital Realty&lt;/a&gt;, &lt;a href=&quot;https://aka.ms/FedEx&quot;&gt;FedEx&lt;/a&gt;, &lt;a href=&quot;https://aka.ms/kroger-on-azure&quot;&gt;Kroger&lt;/a&gt;, &lt;a href=&quot;https://aka.ms/liantis&quot;&gt;Liantis&lt;/a&gt;, &lt;a href=&quot;https://aka.ms/Morgan-Stanley&quot;&gt;Morgan Stanley&lt;/a&gt;, &lt;a href=&quot;https://aka.ms/National-Life&quot;&gt;National Life&lt;/a&gt;, &lt;a href=&quot;https://aka.ms/raleys&quot;&gt;Raley&apos;s&lt;/a&gt;, and &lt;a href=&quot;https://aka.ms/swiss-re&quot;&gt;Swiss Re&lt;/a&gt; adopted the service for their mission-critical enterprise Java Spring applications.&lt;/p&gt;
&lt;p&gt;Azure Spring Apps Enterprise is designed to expedite the development and deployment of enterprise applications by providing commercially supported Spring runtime components and access to Spring experts. Building on the features available in the Standard tier, it allows users to harness the expansive Azure ecosystem to enhance their Spring applications, facilitating a faster path to production and enabling the full realization of Spring&apos;s capabilities.&lt;/p&gt;
&lt;p&gt;Today, we are delighted to announce significant enhancements to the Azure Spring Apps Enterprise. These improvements will bolster security, quicken development speed, amplify scalability, and provide greater flexibility and reliability. We are excited to share these developments with you and look forward to seeing how they will enhance your experiences.&lt;/p&gt;
&lt;h2&gt;Java Apps and GraalVM&lt;/h2&gt;
&lt;p&gt;In the traditional setup, Java applications operate within a Java Runtime Environment (JRE). However, the introduction of the GraalVM Native Image capability marks a significant shift. It lets you compile Java applications into standalone executables, otherwise known as native images. The advantages of this new process are substantial; native images offer quicker startup times and reduced runtime memory overhead when compared to the conventional Java Virtual Machine (JVM). Now, within Azure Spring Apps Enterprise, you have the option to &lt;a href=&quot;https://learn.microsoft.com/en-us/azure/spring-apps/how-to-enterprise-deploy-polyglot-apps?tabs=Portal%2Casa-managed-container-registry#supported-languages-for-deployments&quot;&gt;deploy Spring native image applications&lt;/a&gt; using the &lt;a href=&quot;https://docs.vmware.com/en/VMware-Tanzu-Buildpacks/services/tanzu-buildpacks/GUID-java-native-image-java-native-image-buildpack.html&quot;&gt;Cloud Native Buildpack for Java Native Image&lt;/a&gt;, making the whole process simpler and super-efficient. You can read more about this enhancement below.&lt;/p&gt;
&lt;h2&gt;Enhanced Capabilities&lt;/h2&gt;
&lt;p&gt;In the past five years, our understanding and knowledge have been significantly shaped by the experiences and feedback of developers and customers. We are committed to paying heed to our customers&apos; voices and their needs. Acknowledging the growing demand for running and scaling enterprise applications at a larger scale, we are thrilled to announce a series of enhancements to Azure Spring Apps Enterprise. These enhancements are a direct reflection of our continuous effort to meet and exceed our customers&apos; expectations.&lt;/p&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/joshlong/blog-images/master/azure_spring_apps_enterprise_more_power_scalability_extended_spring_boot_support/1.jpg&quot;&gt;
&lt;p&gt;&lt;em&gt;Figure 1. – Shows the list of Enhancements to Azure Spring Apps Enterprise: Before vs. Now &amp;#x26; User Benefits&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;Explore the enhanced capabilities and their key benefits&lt;/h3&gt;
&lt;p&gt;Let&apos;s look at the enhanced capabilities and their key benefits.&lt;/p&gt;
&lt;h3&gt;Enjoy Enhanced Reliability and Significantly Reduced Downtime&lt;/h3&gt;
&lt;p&gt;Improved Service Level Agreement (SLA): Azure Spring Apps Enterprise now provides an improved SLA of &lt;a href=&quot;https://www.microsoft.com/licensing/docs/view/Service-Level-Agreements-SLA-for-Online-Services?lang=1&quot;&gt;99.95%&lt;/a&gt;, enhancing reliability and reducing the potential downtime for businesses.&lt;/p&gt;
&lt;p&gt;This enhancement promises around 4.34 hours of potential downtime annually, a 50% reduction from the previous SLA. The new SLA provides comprehensive assurance, when all components managed by Azure Spring Apps are taken into consideration. This includes key elements such as Azure Kubernetes Service, Azure Storage, Azure Container Registry, network elements, and various Spring components such as Application Configuration Service, Service Registry, Spring Cloud Gateway, and Tanzu Build Service. In essence, the 99.95% SLA offers a more consistent and reliable service with significantly reduced outages, crucial for businesses with mission-critical operations.&lt;/p&gt;
&lt;p&gt;This comprehensive assurance contrasts markedly with SLAs for do-it-yourself (DIY) application environments where the SLA is an aggregate of various individual services&apos; SLAs and your homegrown control-plane components (if any). For instance, a fully managed K8S service provides an SLA for Kubernetes API server connectivity, but not for nodes running your application workloads. These nodes, being Virtual Machines, carry their own SLA. Services like Azure Storage and Azure Container Registry have their own availability guarantees as well. When you utilize your own ingress controllers and Spring components within a Kubernetes environment, you must ensure all necessary redundancies and instrumentations for measuring SLA and remedying downtime. To achieve an application availability comparable to Azure Spring Apps Enterprise&apos;s 99.95%, you would need to build in redundancies for all service components and your control plane components, and constantly monitor and adjust for any disruptions.&lt;/p&gt;
&lt;h3&gt;Experience Enhanced Scalability – Capacity Increases&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;Increases include enhanced hosting with up to &lt;a href=&quot;https://aka.ms/experience-unparalleled-scalability&quot;&gt;1000 app instances&lt;/a&gt;, large app support, and efficient build processes.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Up to 1000 app instances: The Azure Spring Apps Enterprise now offers a preview of a robust hosting environment capable of accommodating up to 1000 application instances per service instance, providing businesses with the scalability needed for their workloads. With support for up to 8000 virtual CPUs and 32 terabytes of memory per service instance, Azure Spring Apps Enterprise enables organizations to meet demanding computational and memory requirements effectively and efficiently. Of course, you can provision any number of service instances in a region or any number of regions.&lt;/p&gt;
&lt;p&gt;Larger app instances: In addition, the Azure Spring Apps Enterprise offers enhanced value to users by providing support for &lt;a href=&quot;https://learn.microsoft.com/en-us/azure/spring-apps/how-to-enterprise-large-cpu-memory-applications?tabs=azure-portal&quot;&gt;larger app instances&lt;/a&gt;, featuring up to 8 virtual CPUs (vCPU) and 32 gigabytes (GB) of memory per app instance. This increased capacity allows users to deploy resource-intensive applications that require more computational power and memory, enabling them to meet the demands of their workloads effectively.&lt;/p&gt;
&lt;p&gt;Efficient build processes: And to enable more efficient and faster application build processes, especially for complex and resource-intensive applications, Azure Spring Apps Enterprise, has increased the resource allocation for build agent pool  &lt;a href=&quot;https://learn.microsoft.com/en-us/azure/spring-apps/how-to-enterprise-build-service?tabs=azure-portal#configure-the-build-agent-pool&quot;&gt;up to 64 vCPUs and 128 GB&lt;/a&gt; of memory. With these ample resources at your disposal, you can build any app in a highly efficient and resource-rich environment, ensuring a smoother and faster compilation process.&lt;/p&gt;
&lt;h3&gt;Faster Startup Time and Optimized Memory Usage&lt;/h3&gt;
&lt;p&gt;*Java Native Image support: Available now in a preview feature, Azure Spring Apps Enterprise is introducing support for Java native images, promising faster startup times and optimized memory usage. *&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.spring.io/spring-boot/docs/3.0.0/reference/html/native-image.html#native-image&quot;&gt;GraalVM Native Image capability&lt;/a&gt; allows you to compile Java applications to standalone executables, known as native images. These executables can provide significant benefits, including faster startup times and lower runtime memory overhead compared to a traditional JVM (Java Virtual Machine). You can &lt;a href=&quot;https://learn.microsoft.com/en-us/azure/spring-apps/how-to-enterprise-deploy-polyglot-apps?tabs=Portal%2Casa-managed-container-registry#supported-languages-for-deployments&quot;&gt;deploy Spring Boot native image applications&lt;/a&gt; using &lt;a href=&quot;https://docs.vmware.com/en/VMware-Tanzu-Buildpacks/services/tanzu-buildpacks/GUID-java-native-image-java-native-image-buildpack.html&quot;&gt;the Cloud Native Buildpack for Java Native Image&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In Figure 2 below, it shows the optimized memory usage of a native image deployment – which is about 1/5th of the memory consumed by its equivalent JAR deployment - for a constant workload of 400 requests per second into the &lt;a href=&quot;https://aka.ms/petclinic-native&quot;&gt;monolithic version of the Petclinic application&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;GraalVM requires a significant number of resources to build Java native images due to the complexity of the underlying process. The compilation and optimization steps involved in generating native images require substantial computational power and memory.&lt;/p&gt;
&lt;p&gt;In Azure Spring Apps Enterprise, you have the advantage of being able to allocate up to &lt;a href=&quot;https://learn.microsoft.com/en-us/azure/spring-apps/how-to-enterprise-build-service?tabs=azure-portal#configure-the-build-agent-pool&quot;&gt;64 vCPUs and 128 GB&lt;/a&gt; of memory for the build agent pool. With these ample resources at your disposal, you can build your Java native images in a highly efficient and resource-rich environment.&lt;/p&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/joshlong/blog-images/master/azure_spring_apps_enterprise_more_power_scalability_extended_spring_boot_support/2.jpg&quot;&gt;
&lt;p&gt;Figure 2 – Shows optimized memory usage of a native image deployment – about 1/5th of the memory consumed by its equivalent JAR deployment - for a constant workload of 400 requests per second into the monolithic version of the Petclinic application.&lt;/p&gt;
&lt;h3&gt;Bring Your Own Azure Container Registry -- Seamless Deployment Across Environments&lt;/h3&gt;
&lt;p&gt;*Bring your own ACR:  Azure Spring Apps Enterprise now offers the flexibility to bring your own Azure Container Registry (ACR), promoting seamless application deployment across different environments. *&lt;/p&gt;
&lt;p&gt;With Azure Spring Apps Enterprise, users have the advantage of utilizing the &lt;a href=&quot;https://learn.microsoft.com/en-us/azure/spring-apps/how-to-enterprise-build-service?tabs=azure-portal#build-and-deployment-characteristics&quot;&gt;&quot;Bring Your Own Azure Container Registry (ACR)&quot;&lt;/a&gt; feature. This functionality lets users store container images built by Tanzu Build Service within the Azure Spring Apps Enterprise environment, promoting seamless deployment of the same image across various environments, regions, local machines for testing, on-premises setups, and more. Until now, an Azure Spring Apps Enterprise service instance has managed an Azure Container Registry service instance for container images built by Tanzu Build Service, with the Registry bundled within the service instance. But from now on, users can opt between using the Azure Container Registry managed by the service instance or choosing to Bring Your Own Azure Container Registry. This enhancement provides more flexibility and consistency in deployment processes, simplifies management across multiple environments, and facilitates efficient application distribution across different platforms.&lt;/p&gt;
&lt;h3&gt;Assurance for Continuity -- Extended Spring Boot 2.x.x Support until Feb 2025&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;Extended Spring Boot support: Azure Spring Apps Enterprise grants you VMware Spring Runtime Support,  which includes support for Spring Boot 2.x.x until February 2025, providing customers with more time for application upgrades.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Many enterprises and developers may not be aware that open-source support for older versions of the Spring Framework and Spring Boot is set to end in November 2023. This development could leave organizations without commercial support contracts struggling to access patches or security updates. As a result, companies may encounter increased security, compliance, and legal risks.&lt;/p&gt;
&lt;p&gt;Azure Spring Apps Enterprise provides valuable benefits for these developers and customers facing the complex task of upgrading Spring apps. Support for Spring Boot 2.x.x by the open-source community will end on &lt;a href=&quot;https://spring.io/projects/spring-boot#support&quot;&gt;Nov 18th, 2023*&lt;/a&gt;. With the need to navigate through &lt;a href=&quot;https://spring.io/blog/2022/05/24/preparing-for-spring-boot-3-0&quot;&gt;multiple upgrade tasks&lt;/a&gt;, such as transitioning to Java 17, adopting the latest Spring Boot versions, handling deprecated code in Spring Boot 2.x.x, and ensuring compatibility with Jakarta EE 9, developers require adequate time and support. Azure Spring Apps Enterprise users are entitled to commercial support for Spring apps through the VMware Spring Runtime Support. By offering extended commercial support for Spring Boot 2.x.x until February 2025, Azure Spring Apps Enterprise provides a unique cushion for developers and customers, allowing them the necessary time to successfully upgrade their applications while mitigating the risks associated with delayed upgrades, as exemplified by many data breaches and subsequent costly consequences.&lt;/p&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/joshlong/blog-images/master/azure_spring_apps_enterprise_more_power_scalability_extended_spring_boot_support/1.jpg&quot;&gt;
*Figure 3 – Commercial support timeline for Spring Boot*
&lt;p&gt;* You can find the current support timelines for Spring projects at &lt;a href=&quot;https://spring.io/&quot;&gt;https://spring.io/&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Experience Azure Spring Apps Enterprise today!&lt;/h2&gt;
&lt;p&gt;Azure Spring Apps Enterprise delivers simplicity and productivity, and you can leverage Spring experts to make your projects even more successful. You can easily deploy your Spring and polyglot applications to the cloud and get them up and running in no time. It is a golden path to production that simplifies the deployment process and optimizes your resource usage.&lt;/p&gt;
&lt;p&gt;And the best part? We are offering &lt;a href=&quot;https://aka.ms/costs-less&quot;&gt;FREE monthly grants&lt;/a&gt; on all tiers - 50 vCPU hours and 100 GB hours per tier. This is the number of FREE hours you get BEFORE any usage is billed, giving you a chance to test out the service without any financial charges.&lt;/p&gt;
&lt;p&gt;So why wait? Take advantage of our FREE monthly grants and deploy your &lt;a href=&quot;https://aka.ms/Deploy-Spring&quot;&gt;first Spring app&lt;/a&gt; to Azure Spring Apps Enterprise today!&lt;/p&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/joshlong/blog-images/master/azure_spring_apps_enterprise_more_power_scalability_extended_spring_boot_support/4.jpg&quot;&gt;</content:encoded></item><item><title><![CDATA[This Week in Spring - July  11th, 2023]]></title><link>https://spring.io/blog/2023/07/11/this-week-in-spring-july-11th-2023</link><guid isPermaLink="true">https://spring.io/blog/2023/07/11/this-week-in-spring-july-11th-2023</guid><dc:creator><![CDATA[Josh Long]]></dc:creator><pubDate>Tue, 11 Jul 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Hi, Spring fans! Welcome to another installment of &lt;em&gt;This Week in Spring&lt;/em&gt;! I&apos;m in yummy, sunny Jakarta, Indonesia at the moment, preparing for a week of meetings and the &lt;a href=&quot;https://vmware.dekhatroops.com/edm/2023/13-07-2023/3231280985/index.html&quot;&gt;SpringOne Tour Indonesia event later this week&lt;/a&gt;. I&apos;ll also be speaking   &lt;a href=&quot;https://peatix.com/event/3638259/view&quot;&gt;in Kuala Lumpur, Malaysia on July 20th, 2023 &lt;/a&gt;. If you&apos;re in either of these regions, please come out and join me for what is sure to be a ton of fun on our journey to production!&lt;/p&gt;
&lt;p&gt;Anyway, we&apos;ve got a ton of stuff to dive into this week, so let&apos;s get to it.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://spring.io/blog/2023/07/06/a-bootiful-podcast-jetbrains-anton-arhipov-on-intellij-java-and-so-much-more&quot;&gt;A Bootiful Podcast: Jetbrains&apos; Anton Arhipov on IntelliJ, Java, and so much more&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://spring.io/blog/2023/07/05/active-health-check-strategies-with-spring-cloud-gateway&quot;&gt;Active Health Check strategies with Spring Cloud Gateway&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;A fluid, functional-style, non-reactive HTTP client for Spring: &lt;a href=&quot;https://github.com/spring-projects/spring-framework/commit/0820210c7c7dbc0a58730c09196b6b52c4732f17&quot;&gt;Introduce RestClient? spring-projects/spring-framework@0820210&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://piotrminkowski.com/2023/07/05/logging-in-spring-boot-with-loki/&quot;&gt;Logging in Spring Boot with Loki - Piotr&apos;s TechBlog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://link.medium.com/1xEGl3F3dBb&quot;&gt;How I deleted more than 1000 lines of code using Spring Retry&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://link.medium.com/b7H9Ge6tgBb&quot;&gt;ELK + Spring Boot: A Guide to Local Configuration&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://twitter.com/spencerbgibb/status/1677547823938641920?s=12&amp;#x26;t=n-UflcIbnx1lage-TBk0Cg&quot;&gt;the new Spring Cloud Gateway for Spring MVC.fn looks &lt;em&gt;amazing&lt;/em&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Interesting repository: &lt;a href=&quot;https://github.com/hardikSinghBehl/just-another-testcontainer-integration&quot;&gt;Backend application using Testcontainers for Integration Testing AWS S3, Kafka, MySQL, Egress calls and Redis.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://kubernetes.io/blog/2023/07/06/confidential-kubernetes/&quot;&gt;Blog: Confidential Kubernetes: Use Confidential Virtual Machines and Enclaves to improve your cluster security&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://ostara.dev/&quot;&gt;FOSS Admin desktop app for Spring Boot&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[A Bootiful Podcast: Jetbrains' Anton Arhipov on IntelliJ, Java, and so much more ]]></title><link>https://spring.io/blog/2023/07/06/a-bootiful-podcast-jetbrains-anton-arhipov-on-intellij-java-and-so-much-more</link><guid isPermaLink="true">https://spring.io/blog/2023/07/06/a-bootiful-podcast-jetbrains-anton-arhipov-on-intellij-java-and-so-much-more</guid><dc:creator><![CDATA[Josh Long]]></dc:creator><pubDate>Thu, 06 Jul 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Hi, Spring fans! Welcome to another installment of &lt;a href=&quot;https://bootifulpodcast.fm&quot;&gt;&lt;em&gt;A Bootiful Podcast&lt;/em&gt;&lt;/a&gt;! This week  &lt;a href=&quot;https://youtube.com/@coffeesoftware&quot;&gt;Josh Long&lt;/a&gt; talks to &lt;a href=&quot;https://twitter.com/antonarhipov&quot;&gt;Jetbrain&apos;s developer advocate Anton Arhipov&lt;/a&gt;, recorded live from the amazing Spring IO show in Barcelona, Spain!&lt;/p&gt;
&lt;iframe title=&quot;Jetbrains’ Anton Arhipov on IntelliJ, Java, and so much more &quot; allowtransparency=&quot;true&quot; height=&quot;150&quot; width=&quot;100%&quot; style=&quot;border: none; min-width: min(100%, 430px);height:150px;&quot; scrolling=&quot;no&quot; data-name=&quot;pb-iframe-player&quot; src=&quot;https://www.podbean.com/player-v2/?i=y8vqh-144da48-pb&amp;from=pb6admin&amp;share=1&amp;download=1&amp;rtl=0&amp;fonts=Arial&amp;skin=1&amp;font-color=&amp;logo_link=episode_page&amp;btn-skin=7&quot; loading=&quot;lazy&quot;&gt;&lt;/iframe&gt;</content:encoded></item><item><title><![CDATA[Active Health Check strategies with Spring Cloud Gateway]]></title><link>https://spring.io/blog/2023/07/05/active-health-check-strategies-with-spring-cloud-gateway</link><guid isPermaLink="true">https://spring.io/blog/2023/07/05/active-health-check-strategies-with-spring-cloud-gateway</guid><dc:creator><![CDATA[Ignacio Lozano]]></dc:creator><pubDate>Wed, 05 Jul 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Active health check strategies with Spring Cloud Gateway&lt;/h1&gt;
&lt;p&gt;Nowadays, applications are built as a collection of small independent upstream services. This accelerates development and allows modules to be focused on specific responsibilities, increasing their quality. This is one of the main advantages of using a microservice approach. However, jumping from one service to another can add extra latency, and this latency can be dramatically higher when the services are not responding.&lt;/p&gt;
&lt;p&gt;If you run microservices, you want to prevent your upstream services from being called when they are not working properly. Even using a circuit breaker pattern can also generate a penalty in the response time. For this reason, it is sometimes better to actively check your upstream services to verify they are ready before they are needed.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A health check is a way to determine if a service can respond correctly according to its status, preventing timeouts and errors.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Passive health check&lt;/strong&gt; is done during request handling. If the service is finally unhealthy, the application will return a failure marking the endpoint unhealthy. It can add extra latency.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Active health check&lt;/strong&gt; will check and drop unhealthy services in the background before receiving the request. It doesn&apos;t add extra latency.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Last but not least, these features can be combined with a circuit breaker library to immediately fall back on an alternative endpoint without suffering the first miss penalty.&lt;/p&gt;
&lt;p&gt;The goal is for routes to forward the requests to upstream services that are healthy by using a load balancer strategy:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//images.ctfassets.net/mnrwi97vnhts/4X00jJADrVtK5bXFIGElTl/01ba8c47bf7599a9cab637333b96b672/active-hc-diagram.png&quot; alt=&quot;Active Health Check Diagram&quot;&gt;&lt;/p&gt;
&lt;p&gt;This post is divided into two parts:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&quot;Spring features you need&quot; - describing which Spring’s features you need to get active health check.&lt;/li&gt;
&lt;li&gt;&quot;Registering endpoints for your services&quot; - visiting some approaches for adding one or more endpoints to your routes.&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;1. Spring features you need&lt;/h1&gt;
&lt;p&gt;There are some features in Spring that can help you to get active health check&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Spring Cloud Load Balancer&lt;/strong&gt; (SLB) is a client-side load-balancer that allows balancing traffic between different upstream service endpoints. It is part of &lt;a href=&quot;https://spring.io/projects/spring-cloud&quot;&gt;Spring Cloud project&lt;/a&gt;, and is included in the spring-cloud-commons library (see the &lt;a href=&quot;https://docs.spring.io/spring-cloud-commons/docs/current/reference/html/#spring-cloud-loadbalancer&quot;&gt;SLB documentation&lt;/a&gt;).&lt;/li&gt;
&lt;li&gt;The client-side service discovery feature lets the client find and communicate with services without hard-coding the hostname and port. It is also included in the spring-cloud-commons library (see the &lt;a href=&quot;https://docs.spring.io/spring-cloud-commons/docs/current/reference/html/#discovery-client&quot;&gt;Service Discovery documentation&lt;/a&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Spring Cloud Gateway&lt;/strong&gt;
&lt;a href=&quot;https://cloud.spring.io/spring-cloud-gateway&quot;&gt;Spring Cloud Gateway&lt;/a&gt; provides a library for building API gateways on top of Spring and Java.
It supports the above features through the &lt;a href=&quot;https://cloud.spring.io/spring-cloud-gateway/2.1.x/multi/multi__global_filters.html#_loadbalancerclient_filter&quot;&gt;LoadBalancerClientFilter&lt;/a&gt;/&lt;a href=&quot;https://cloud.spring.io/spring-cloud-gateway/2.1.x/multi/multi__global_filters.html#reactive-loadbalancer-client-filter&quot;&gt;ReactiveLoadBalancerClientFilter&lt;/a&gt; global filters.
In this post, you can see different ways to use one of those global filters.&lt;/p&gt;
&lt;p&gt;First, though, let’s explore some of those features.&lt;/p&gt;
&lt;h3&gt;Spring Cloud Load Balancer filter&lt;/h3&gt;
&lt;p&gt;A global filter for load balancing is included in Spring Cloud and can be activated by using a special URI notation: &lt;code&gt;lb://your-service-name&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;spring:
 cloud:
   gateway:
     routes:
       - id: myRoute
         uri: lb://your-service-name
         predicates:
         - Path=/service/**
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The load balancer filter, &lt;a href=&quot;https://cloud.spring.io/spring-cloud-gateway/2.1.x/multi/multi__global_filters.html#reactive-loadbalancer-client-filter&quot;&gt;ReactiveLoadBalancerClientFilter&lt;/a&gt; (for reactive applications), will detect the URI and replace it with an available endpoint associated with &quot;your-service-name&quot;.&lt;/p&gt;
&lt;p&gt;Take into account that you need to register &quot;your-service-name&quot; in the Service Discovery registry. We will see different ways you can do it in the following sections.&lt;/p&gt;
&lt;h3&gt;Active health check&lt;/h3&gt;
&lt;p&gt;By default, traffic is routed to upstream services, even if they are unhealthy.
To prevent picking a bad one, you can enable the &lt;code&gt;health-check&lt;/code&gt; configuration provided by the Load Balancer Client from Spring Cloud:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;    spring:
      cloud:  
        loadbalancer:  
          configurations: health-check
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;All the endpoints will be checked periodically by automatically using the Spring Boot Actuator health endpoint.
You can also customize some options like &lt;code&gt;spring.cloud.loadbalancer.health-check.&amp;#x3C;your-service-name&gt;.path&lt;/code&gt; and &lt;code&gt;spring.cloud.loadbalancer.health-check.interval&lt;/code&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The default health check configuration checks the upstream service endpoints by using the &lt;code&gt;/actuator/health&lt;/code&gt; endpoint, which requires activating Spring Actuator in your upstream service.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;For more options, explore the &lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-commons/blob/main/spring-cloud-commons/src/main/java/org/springframework/cloud/client/loadbalancer/LoadBalancerClientsProperties.java&quot;&gt;LoadBalancerClientsProperties&lt;/a&gt; and &lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-commons/blob/main/spring-cloud-commons/src/main/java/org/springframework/cloud/client/loadbalancer/LoadBalancerProperties.java&quot;&gt;LoadBalancerProperties&lt;/a&gt; classes&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;There is a built-in feature in Spring Cloud Gateway that will deploy all the services available as routes. This post describes the opposite, so we are declaring routes that are load balanced, including active health check.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;2. Registering endpoints for your services&lt;/h1&gt;
&lt;p&gt;In the previous section, you specified a load-balanced URI (&lt;code&gt;lb://your-service-name&lt;/code&gt;), but now you need to register the endpoints associated with the service name of the URI.
We are visiting some approaches in the following sections.&lt;/p&gt;
&lt;h2&gt;Static approach&lt;/h2&gt;
&lt;p&gt;You can statically activate client load balancing by configuring the &lt;code&gt;spring.cloud.discovery.client.simple.instances&lt;/code&gt; property.
It is a map whose key is the service name (used by the lb:// URI) and the value is an array of &lt;code&gt;org.springframework.cloud.client.ServiceInstance&lt;/code&gt; objects that point to the upstream services.&lt;/p&gt;
&lt;p&gt;Some benefits of static load balancing include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Load balancing could distribute traffic between multiple instances, sharing any stress of the services and reducing the probability of crashing.&lt;/li&gt;
&lt;li&gt;Fault tolerance.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The problem is that you are statically setting the upstream services in your configuration. If you need to change the list, you need to restart your application.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;spring:
  cloud:
    gateway:
      routes:
        - uri: lb://hello-service # Load Balancer URI handled by ReactiveLoadBalancerClientFilter
          predicates:
            - Path=/hello
    loadbalancer:
      configurations: health-check # Required for enabling SDC with health checks
    discovery:
      client:
        simple: # SimpleDiscoveryClient to configure statically services
          instances:
            hello-service:
              - secure: false
                port: 8090
                host: localhost
                serviceId: hello-service
                instanceId: hello-service-1
              - secure: false
                port: 8091
                host: localhost
                serviceId: hello-service
                instanceId: hello-service-2
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Trying out&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Run servers&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;# Run server 1
SERVER_PORT=8090 ./gradlew :service:bootRun
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;# Run server 2
SERVER_PORT=8091 ./gradlew :service:bootRun
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Check &lt;a href=&quot;http://localhost:8090/actuator/health&quot;&gt;http://localhost:8090/actuator/health&lt;/a&gt; is &quot;UP&quot;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;curl http://localhost:8090/actuator/health
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt; {&quot;status&quot;:&quot;UP&quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;Test &lt;a href=&quot;http://localhost:8080/hello&quot;&gt;http://localhost:8080/hello&lt;/a&gt; responds 200 OK&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;curl localhost:8090/hello
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;{ &quot;message&quot;: &quot;hello world!&quot;}%
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;Run Spring Cloud Gateway&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;./gradlew :1-service-disc-by-properties:bootRun
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;Test Spring Cloud Gateway balancer&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;curl localhost:8881/hello
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;{ &quot;message&quot;: &quot;hello world from port 8090!&quot;}%
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;curl localhost:8881/hello
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;{ &quot;message&quot;: &quot;hello world from port 8091!&quot;}%
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You could need to run multiple times the previous commands to get a response from a different server.&lt;/p&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;Mark server 1 as unhealthy sending PUT request to &lt;a href=&quot;http://localhost:8090/status/false&quot;&gt;http://localhost:8090/status/false&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;curl localhost:8090/status/false -X PUT
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;7&quot;&gt;
&lt;li&gt;Check &lt;a href=&quot;http://localhost:8090/actuator/status&quot;&gt;http://localhost:8090/actuator/status&lt;/a&gt; is &quot;DOWN&quot;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;curl http://localhost:8090/actuator/health
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;{&quot;status&quot;:&quot;DOWN&quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;8&quot;&gt;
&lt;li&gt;Run multiple times a GET request to &lt;a href=&quot;http://localhost:8881/hello&quot;&gt;http://localhost:8881/hello&lt;/a&gt; and see that you only get response from port 8091&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;You could receive one response on port 8090 owing the healthcheck haven&apos;t checked the endpoint when you send the request.
The interval can be modified in the property spring.cloud.loadbalancer.health-check.interval &lt;code&gt;spring.cloud.loadbalancer.health-check.interval&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Also, you can see some messages that describe one of the upstream endpoints as not healthy, and therefore, it is unavailable.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2023-05-08 14:59:53.151 DEBUG 9906 --- [ctor-http-nio-3] r.n.http.client.HttpClientOperations     : [12d42e83-77, L:/127.0.0.1:57439 - R:localhost/127.0.0.1:8090] Received response (auto-read:false) : RESPONSE(decodeResult: success, version: HTTP/1.1)
HTTP/1.1 503 Service Unavailable
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;curl localhost:8881/hello
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;{ &quot;message&quot;: &quot;hello world from port 8091!&quot;}%
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;9&quot;&gt;
&lt;li&gt;Mark server 2 as unhealthy sending PUT request to &lt;a href=&quot;http://localhost:8091/status/false&quot;&gt;http://localhost:8091/status/false&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;curl localhost:8091/status/false -X PUT
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;10&quot;&gt;
&lt;li&gt;Run some GET requests to &lt;a href=&quot;http://localhost:8881/hello&quot;&gt;http://localhost:8881/hello&lt;/a&gt; and see that it responds &quot;503 Service Unavailable&quot;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;curl localhost:8881/hello
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;{&quot;timestamp&quot;:&quot;2023-05-08T13:07:48.704+00:00&quot;,&quot;path&quot;:&quot;/hello&quot;,&quot;status&quot;:503,&quot;error&quot;:&quot;Service Unavailable&quot;,&quot;requestId&quot;:&quot;6b5d6010-199&quot;}%
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;11&quot;&gt;
&lt;li&gt;Stop all the servers started in the previous steps&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Eureka integration (+complex, dynamic)&lt;/h2&gt;
&lt;p&gt;Having a static configuration is not very flexible, but using Eureka as a service discovery can remove that drawback.&lt;/p&gt;
&lt;p&gt;The cost is that you require a new component in your architecture which can increase your maintenance burden. This might not be an option for some clients.&lt;/p&gt;
&lt;p&gt;The following example configures Eureka integration:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;    spring:
      application:
        name: scg-client-with-eureka
      cloud:
        loadbalancer:
          configurations: health-check # Note: required for enabling SDC with health checks - remove this line if you want to reproduce issues because not using health checks in LB
          # Note: LoadBalancerCacheProperties.ttl (or spring.cloud.loadbalancer.cache.ttl) is 35 by default - You will need to wait 35secs after an instance turns healthy
        gateway:
          httpclient:
            wiretap: true
          routes:
            - uri: lb://hello-service
              predicates:
                - Path=/headers
              filters:
                - StripPrefix=0

    eureka:
      client:
        webclient:
          enabled: true
        serviceUrl:
          defaultZone: http://localhost:8761/eureka
        fetchRegistry: true
        registerWithEureka: false
      instance:
        preferIpAddress: true
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Trying out&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Run Eureka Server&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;./gradlew :eureka-server:bootRun
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Wait until you can see Eureka server was started up&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2023-06-26 12:51:46.901  INFO 88601 --- [       Thread-9] e.s.EurekaServerInitializerConfiguration : Started Eureka Server
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Run servers including &lt;code&gt;eureka&lt;/code&gt; profile&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;# Run server 1
SPRING_PROFILES_ACTIVE=eureka SERVER_PORT=8090 ./gradlew :service:bootRun
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;# Run server 2
SPRING_PROFILES_ACTIVE=eureka SERVER_PORT=8091 ./gradlew :service:bootRun
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You should see that the sever instances were added into Eureka in the servers&apos; logs from step 1.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2023-06-26 12:52:50.805  INFO 88601 --- [nio-8761-exec-3] c.n.e.registry.AbstractInstanceRegistry  : Registered instance HELLO-SERVICE/192.168.0.14:hello-service:8090 with status UP (replication=true)
2023-06-26 12:53:29.127  INFO 88601 --- [nio-8761-exec-9] c.n.e.registry.AbstractInstanceRegistry  : Registered instance HELLO-SERVICE/192.168.0.14:hello-service:8091 with status UP (replication=true)
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;
&lt;p&gt;Go to &lt;a href=&quot;http://localhost:8761/&quot;&gt;http://localhost:8761/&lt;/a&gt; and check the servers are included  as instance of the application &lt;code&gt;hello-service&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Run Spring Cloud Gateway&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;SERVER_PORT=8883 ./gradlew :3-eureka-service-disc:bootRun
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.Test Spring Cloud Gateway balancer&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;curl localhost:8883/hello
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;{ &quot;message&quot;: &quot;hello world from port 8090!&quot;}%
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;curl localhost:8883/hello
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;{ &quot;message&quot;: &quot;hello world from port 8091!&quot;}%
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;Mark server 1 as unhealthy sending PUT request to &lt;a href=&quot;http://localhost:8090/status/false&quot;&gt;http://localhost:8090/status/false&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;curl localhost:8090/status/false -X PUT
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You should see in the Eureka dashboard that there is only one instance available, and you will see some logs messages complaining that service on port &lt;code&gt;8090&lt;/code&gt; is not available.
The health check is not immediate, so you might need to wait a few seconds to see the instance marked as DOWN.&lt;/p&gt;
&lt;ol start=&quot;7&quot;&gt;
&lt;li&gt;Stop all the servers started in the previous steps&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Custom Filter at Route level (dynamic approach)&lt;/h2&gt;
&lt;p&gt;As you have seen, Spring Cloud Gateway offers an option for creating your own custom filters. It also lets you apply filters and change routes without restarting your gateway.&lt;/p&gt;
&lt;p&gt;In this section, you can see a custom filter implementation that sets up load balancing and health checks of your services by using Spring Cloud Gateway route configuration.&lt;/p&gt;
&lt;p&gt;If you already have a service discovery server in your project this might not be your best option. If not, this is a simple and cheap way to integrate two great features in your project.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;    spring:
      application:
        name: custom-service-disc
      cloud:
        loadbalancer:
          configurations: health-check # Note: required for enabling SDC with health checks - remove this line if you want to reproduce issues because not using health checks in LB
          # Note: LoadBalancerCacheProperties.ttl (or spring.cloud.loadbalancer.cache.ttl) is 35 by default - You will need to wait 35secs after an instance turns healthy
        gateway:
          routes:
            - uri: lb://hello-service
              id: load-balanced
              predicates:
                - Path=/load-balanced/**
              filters:
                - StripPrefix=1
                - LoadBalancer=localhost:8090;localhost:8091;localhost:8092
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The new &lt;code&gt;LoadBalancer&lt;/code&gt; route filter lets you configure the upstream service endpoints associated with the &lt;code&gt;lb://hello-service&lt;/code&gt; load balancer URI:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Component
public class LoadBalancerGatewayFilterFactory extends AbstractGatewayFilterFactory&amp;#x3C;LoadBalancerGatewayFilterFactory.MyConfiguration&gt; {

	// ...

	@Override
	public GatewayFilter apply(MyConfiguration config) {
		return (exchange, chain) -&gt; {
			final Route route = exchange.getAttribute(GATEWAY_ROUTE_ATTR);
			if (StringUtils.hasText(config.getInstances()) &amp;#x26;&amp;#x26; route.getUri().getScheme().equals(&quot;lb&quot;)) {
				config.getServiceInstances(route.getUri().getHost()).forEach(discoveryClient::addInstance);
			}

			return chain.filter(exchange);
		};
	}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If a route matches the &lt;code&gt;lb://&amp;#x3C;service-host&gt;&lt;/code&gt; pattern, the &lt;code&gt;LoadBalancerGatewayFilterFactory&lt;/code&gt; will associate all the upstream service endpoints coming from the filter configuration to the &lt;code&gt;service-host&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Under the hood, a new &lt;code&gt;ReactiveCustomDiscoveryClient&lt;/code&gt; discovery client implementation has been included to manage upstream service endpoints in our code.
Spring detects such a bean and prioritizes it in the list of &lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-commons/blob/main/spring-cloud-commons/src/main/java/org/springframework/cloud/client/discovery/DiscoveryClient.java&quot;&gt;DiscoveryClient&lt;/a&gt; used to determine available endpoints.&lt;/p&gt;
&lt;h3&gt;Trying out&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Run servers&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;# Run server 1
SERVER_PORT=8090 ./gradlew :service:bootRun
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;# Run server 2
SERVER_PORT=8091 ./gradlew :service:bootRun
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Check &lt;a href=&quot;http://localhost:8090/actuator/health&quot;&gt;http://localhost:8090/actuator/health&lt;/a&gt; is &quot;UP&quot;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;curl http://localhost:8090/actuator/health
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;{&quot;status&quot;:&quot;UP&quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;Test &lt;a href=&quot;http://localhost:8080/hello&quot;&gt;http://localhost:8080/hello&lt;/a&gt; responds 200 OK&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;curl localhost:8090/hello
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;{ &quot;message&quot;: &quot;hello world!&quot;}%
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;Run Spring Cloud Gateway&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;SERVER_PORT=8882 ./gradlew :2-custom-service-disc:bootRun
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;Test Spring Cloud Gateway balancer&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;curl localhost:8882/hello
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;{ &quot;message&quot;: &quot;hello world from port 8090!&quot;}%
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;curl localhost:8882/hello
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;{ &quot;message&quot;: &quot;hello world from port 8091!&quot;}%
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You could need to run multiple times the previous commands to get a response from a different server.&lt;/p&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;Mark server 1 as unhealthy sending PUT request to &lt;a href=&quot;http://localhost:8090/status/false&quot;&gt;http://localhost:8090/status/false&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;curl localhost:8090/status/false -X PUT
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;7&quot;&gt;
&lt;li&gt;Check &lt;a href=&quot;http://localhost:8090/actuator/status&quot;&gt;http://localhost:8090/actuator/status&lt;/a&gt; is &quot;DOWN&quot;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;curl http://localhost:8090/actuator/health
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;{&quot;status&quot;:&quot;DOWN&quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;8&quot;&gt;
&lt;li&gt;Run multiple times a GET request to &lt;a href=&quot;http://localhost:8881/hello&quot;&gt;http://localhost:8881/hello&lt;/a&gt; and see that you only gets responds from port 8091&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;You could receive one response on port &lt;code&gt;8090&lt;/code&gt; owing to the healthcheck not having checked the endpoint when you send the request.
The interval can be modified in the &lt;code&gt;spring.cloud.loadbalancer.health-check.interval&lt;/code&gt; property.&lt;/p&gt;
&lt;p&gt;Also, you can see some messages that describe one of the upstream endpoints as not healthy, and, therefore, it is unavailable.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2023-05-08 15:59:53.151 DEBUG 9906 --- [ctor-http-nio-2] r.n.http.client.HttpClientOperations     : [12d42e83-77, L:/127.0.0.1:57439 - R:localhost/127.0.0.1:8090] Received response (auto-read:false) : RESPONSE(decodeResult: success, version: HTTP/1.1)
HTTP/1.1 503 Service Unavailable
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;curl localhost:8882/hello
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;{ &quot;message&quot;: &quot;hello world from port 8091!&quot;}%
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;9&quot;&gt;
&lt;li&gt;Mark server 2 as unhealthy sending PUT request to &lt;a href=&quot;http://localhost:8091/status/false&quot;&gt;http://localhost:8091/status/false&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;curl localhost:8091/status/false -X PUT
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;10&quot;&gt;
&lt;li&gt;Run some GET requests to &lt;a href=&quot;http://localhost:8881/hello&quot;&gt;http://localhost:8881/hello&lt;/a&gt; and see that it responds &quot;503 Service Unavailable&quot;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;curl localhost:8882/hello
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;{&quot;timestamp&quot;:&quot;2023-05-08T14:07:48.704+00:00&quot;,&quot;path&quot;:&quot;/hello&quot;,&quot;status&quot;:503,&quot;error&quot;:&quot;Service Unavailable&quot;,&quot;requestId&quot;:&quot;6b5d6010-199&quot;}%
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;11&quot;&gt;
&lt;li&gt;Stop all the servers started in the previous steps&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Next steps&lt;/h3&gt;
&lt;p&gt;In this post, you have seen multiple ways to get load balancing and active health checks in your projects.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;From the static approach for basic projects or proof of concepts where the number of upstream services doesn’t change.&lt;/li&gt;
&lt;li&gt;As a more dynamic approach, using Eureka or Spring Cloud Gateway filters.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To sum up, you have also seen that the Spring Cloud Gateway approach is a great option if you do not need to add an extra component to your architecture.&lt;/p&gt;
&lt;h1&gt;Additional Resources&lt;/h1&gt;
&lt;p&gt;Want to learn more about Spring Cloud? Join us virtually at &lt;a href=&quot;https://spring.academy&quot;&gt;Spring Academy&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;Want to get &lt;strong&gt;active health check&lt;/strong&gt; just by adding a property in your route without getting your hands dirty?
Take a look at our &lt;a href=&quot;https://docs.vmware.com/en/VMware-Spring-Cloud-Gateway-for-Kubernetes/index.html&quot;&gt;commercial platform with Kubernetes&lt;/a&gt; support.&lt;/p&gt;</content:encoded></item></channel></rss>